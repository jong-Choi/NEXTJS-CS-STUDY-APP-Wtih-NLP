[{"id":0,"category":"프론트엔드 전반","title":"CSR(Client Side Rendering)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"CSR에선 브라우저가 서버에 HTML과 JS 파일을 요청한 후 로드되면 사용자의 상호작용에 따라 JS를 이용해서 동적으로 렌더링을 시킨다.\n\n👍 장점\n첫 로딩만 기다리면, 동적으로 빠르게 렌더링이 되기 때문에 사용자 경험(UX)이 좋다.\n서버에게 요청하는 횟수가 훨씬 적기 때문에 서버의 부담이 덜하다.\n👎 단점\n모든 스크립트 파일이 로드될 때까지 기다려야 한다.\n리소스를 청크(Chunk) 단위로 묶어서 요청할 때만 다운받게 하는 방식으로 완화시킬 수 있지만 완벽히 해결할 수는 없다.\n검색엔진의 검색 봇이 크롤링을 하는데 어려움을 겪기 때문에 검색엔진 최적화(Search Engine Optimization)의 문제가 있다.\n구글 봇의 경우는 JS를 지원하지만, 다른 검색엔진의 경우 그렇지 않기 때문에 문제가 된다.","keywordArray":["CSR","브라우저","서버","JS 파일","사용자","상호 작용","JS","동적","렌더링","동적","렌더링","UX","서버","횟수","서버","부담","스크립트 파일","리소스","단위","방식","검색 엔진","검색 봇","크롤 링","어려움","Search Engine Optimization","문제","구글 봇","JS","검색 엔진","문제"]},{"id":1,"category":"프론트엔드 전반","title":"브라우저의 렌더링 과정","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"브라우저가 화면에 나타나는 요소를 렌더링 할 때, 웹킷(Webkit)이나 게코(Gecko) 등과 같은 렌더링 엔진 을 사용한다. 렌더링 엔진이 HTML, CSS, Javascript로 렌더링할 때 CRP(Critical Rendering Path) 라는 프로세스를 사용하며 다음 단계들로 이루어진다.\n\nHTML 파싱 후, DOM(Document Object Model) 트리 구축\nCSS 파싱 후, CSSOM(CSS Object Model) 트리 구축\nJavascript 실행\n주의! HTML 중간에 스크립트가 있다면 HTML 파싱이 중단된다.\nDOM과 CSSOM을 조합하여 렌더트리(Render Tree) 구축\n주의! display: none 속성과 같이 화면에서 보이지도 않고 공간을 차지하지 않는 것은 렌더트리로 구축되지 않는다.\n뷰포트 기반으로 렌더트리의 각 노드가 가지는 정확한 위치와 크기 계산 (Layout/Reflow 단계)\n계산한 위치/크기를 기반으로 화면에 그림 (Paint 단계)","keywordArray":["브라우저","화면","요소","렌더링 엔진","렌더링 엔진","Javascript","프로세스","다음 단계들","HTML 중간","스크립트","HTML 파싱","CSSOM","none 속성","화면","공간","렌더트리","뷰포트 기반","렌더트리","노드","크기","기반","화면"]},{"id":2,"category":"프론트엔드 전반","title":"자바스크립트 엔진이 코드를 실행하는 과정","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"소스코드를 만나면 파싱하여 AST(Abstract Syntax Tree) 로 변환한다.\n인터프리터(Interpreter) 는 AST를 기반으로 바이트코드(Bytecode)를 생성 한다.\n인터프리터가 바이트코드를 실행할 때, 자주 사용되는 함수 및 타입 정보 등이 있는 프로파일링 데이터(Profiling data) 와 같이 최적화 컴파일러(Optimizing compiler) 에게 보낸다.\n최적화 컴파일러는 프로파일링 데이터를 기반으로 최적화된 코드(Optimized code)를 생성 한다.\n하지만, 프로파일링 데이터 중에 잘못된 부분이 있다면 최적화 해제(Deoptimize) 를 하고 다시 바이트코드를 실행해서 이전 동작을 반복한다.","keywordArray":["소스 코드","Abstract Syntax Tree","AST","기반","Bytecode","인터프리터","바이트 코드","Profiling data","Optimizing compiler","프로파일링데이터","기반","Optimized code","부분","Deoptimize","바이트 코드","이전 동작"]},{"id":3,"category":"프론트엔드 전반","title":"트랜스파일러","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"트랜스파일링(Transpiling)이란 특정 언어로 작성된 코드를 비슷한 다른 언어로 변환시키는 행위 를 말하며 이를 해주는 것이 트랜스파일러(Transpiler)이다. 트랜스파일러가 필요한 이유는 모든 브라우저가 ES6+의 기능을 제공하지 않기 때문에 이를 ES5 코드로 변환시키는 과정이 필요하다. 트랜스파일러는 이 작업을 수행해준다. 사실 ES6+의 기능 뿐만 아니라 리액트의 JSX를 자바스크립트 코드로 변환시킨다거나 타입스크립트를 자바스크립트로 변환시키는 등의 역할도 트랜스파일러의 기능 중에 하나이다. ES6+나 JSX를 변환시키는 트랜스파일러로는 바벨(Babel)이 있으며 타입스크립트를 변환시키는 도구로는 타입스크립트 트랜스파일러가 있다. 보통 프론트엔드 프레임워크 및 라이브러리를 사용해서 개발할 때 모듈 번들러에 트랜스파일러를 추가해서 사용하는 방식을 사용한다.","keywordArray":["특정 언어","코드","언어","행위","말하","트랜스파일러","브라우저","ES","기능","코드","과정","작업","ES","리액트","JSX","자바스크립트 코드","타입스크립트","자바스크립트","트랜스파일러","JSX","트랜스파일러","Babel","타입스크립트","도구","타입스크립트 트랜스파일러","라이브러리","때 모듈 번들러","트랜스파일러","방식"]},{"id":4,"category":"프론트엔드 전반","title":"CI (Continuous Integration, 지속적 통합)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"CI는 빌드와 테스트를 자동화해서 공유 저장소에 병합시키는 프로세스를 뜻한다. git과 같은 버전관리 시스템을 사용할 때 여러명의 개발자가 하나의 공유 저장소를 사용하는 경우가 많다. 이렇게 되면 새로운 코드의 변경 사항이 저장소에 통합되지 않을 경우 서로 충돌할 수 있다. 따라서 빌드/테스트 자동화부터 코드의 일관성(Consistency)을 제공하기 때문에 지속적으로 통합한다는 용어를 사용하는 것이다.","keywordArray":["테스트","공유 저장소","프로세스","git","버전 관리 시스템","개발자","하나","공유 저장소","경우","코드","변경 사항","저장소","코드","Consistency","지속적","용어"]},{"id":5,"category":"프론트엔드 전반","title":"CD (Continuous Delivery/Deploy, 지속적 전달/배포)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"CD는 CI의 빌드/테스트를 통해서 정상적으로 수행됨을 확인하면 이는 배포를 수동으로 하느냐 자동으로 하느냐에 따라 2가지로 나뉜다.\n\n지속적 전달 : 프로덕션 배포를 위한 상태가 되고 배포 자체는 수동으로 실행한다.\n개발팀과 비즈니스팀간의 커뮤니케이션 부족 문제를 해결한다.\n지속적 배포 : 프로덕션까지 자동으로 배포한다.\n어플리케이션의 제공 속도를 증가시킨다.","keywordArray":["CI","테스트","정상적","수행되","배포","수동","자동","자동","프로덕션 배포","상태","수동","커뮤니케이션 부족 문제","자동","어플리케이션","제공 속도"]},{"id":6,"category":"HTML","title":"DOCTYPE","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"DOCTYPE은 Document Type의 약자로, HTML이 어떤 버전으로 작성되었는지 미리 선언하여 웹브라우저가 내용을 올바로 표시할 수 있도록 해주는 것 이다. <!DOCTYPE> 으로 선언하는데 이걸 해주지 않으면 호환 모드(quirks mode) 로 동작한다. 호환 모드의 경우 각 브라우저마다 문서를 나타내는 방식이 다르기 때문에 크로스 브라우징 이슈가 훨씬 심해지게 된다.","keywordArray":["Document Type","약자","HTML","버전","웹 브라우저가 내용","DOCTYPE","선언하","quirks mode","호환 모드","문서","방식","크로스 브라우징 이슈"]},{"id":7,"category":"HTML","title":"DTD(Document Type Definition)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"DTD(Document Type Definition)란 문서 형식을 정의해놓은 것으로 DOCTYPE을 명시할 때 사용한다. 즉, HTML 문서가 어떤 문서 형식을 따르는지 DOCTYPE에서 DTD를 지정하는 것이다.\n\n예시로 아래와 같은 것들이 있고 W3C Recommended list of Doctype declarations 에서 더욱 자세하게 확인 가능하다.\n\nXHTML 1.1\nXHTML 1.0\nStrict DTD\nTransitional DTD\nFrameset DTD\nHTML 4.01\nStrict DTD\nTransitional DTD\nFrameset DTD\nHTML 5\n현 시점에선, HTML 5의 DTD로 DOCTYPE을 명시하는 것이 제일 바람직하다.\n\n<!DOCTYPE html>","keywordArray":["문서 형식","DOCTYPE","HTML 문서","문서 형식","DOCTYPE","DTD","예시","아래","C Recommended list of Doctype declarations","시점","HTML","DTD","DOCTYPE"]},{"id":8,"category":"HTML","title":"표준 모드와 호환 모드","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"과거의 웹 페이지는 넷스케이프와 익스플로러 버전이 따로 존재했고 웹 표준이 없었다. 그러나 W3C가 웹 표준을 만들면서 브라우저가 웹사이트를 제대로 표현할 수 없게 되자 렌더링을 할 때 표준 모드(Standards mode)와 호환 모드(Quirks mode)로 렌더링을 할 수 있게 옵션을 제공하였다.\n\n브라우저는 HTML 문서가 DOCTYPE을 가지고 있지 않으면 호환 모드로 렌더링을 하고, 가지고 있다면 주어진 DOCTYPE에 맞게 표준 모드로 렌더링을 한다. 호환 모드로 렌더링을 하게 되면 오래된 웹페이지들을 최신 버전의 브라우저에서도 깨지지 않게 하기 때문에 각 브라우저마다 다르게 보일 수 있다. 예를 들어, IE의 경우 호환 모드에서 박스 모델(Box model)을 잘못 해석하지만, 나머지 브라우저들은 그렇지 않다.\n\n결론적으로, 정말 특별한 경우가 아니라면 DOCTYPE을 명시하여 브라우저가 표준 모드로 렌더링 하게 하자. 현재 시점에서 HTML5에서 권장하는 방식인 <!DOCTYPE html> 을 사용하는 것이 가장 바람직하다.","keywordArray":["과거","익스플로러 버전","웹 표준","C","웹 표준","브라우저","웹 사이트","렌더링","Quirks mode","렌더링","옵션","HTML 문서","DOCTYPE","호환 모드","렌더링","DOCTYPE","표준 모드","렌더링","호환 모드","렌더링","웹 페이지들","최신 버전","브라우저","예","IE","경우 호환 모드","Box model","결론","경우","DOCTYPE","브라우저","표준 모드","시점","HTML","DOCTYPE html"]},{"id":9,"category":"HTML","title":"data- 속성","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"data-속성이란 DOM에 데이터를 저장할 수 있는 사용자 정의 데이터 속성 으로 data- 다음 오는 값이 데이터가 된다. 이 속성은 사용하고자 하는 용도에 적합한 속성이나 요소가 없을 때 사용하며 해당 웹페이지가 독자적으로 사용하는 값 이다. 즉, 웹페이지와 독립적인 소프트웨어가 이 속성을 사용해서는 안된다.\n\n예를 들어, 음악 사이트에서 앨범 트랙의 음악을 리스트 형식으로 나타내는데 그걸 시간 순으로 정렬하기 위해서 data- 속성으로 음악 시간을 삽입한다고 하자.\n\n<ol>\n  <li data-length=\"2m11s\">빨간맛</li>\n  ...\n</ol>\n만약 이 음악 사이트와 전혀 상관이 없는 외부에서 음악 시간을 알아내기 위해 사용한다면 목적에 부합하지 않는 것이다. 따라서, data- 속성은 해당 사이트만의 자체 스크립트를 위한 속성이라고 할 수 있다.","keywordArray":["DOM","데이터","사용자정","데이터 속성","값","데이터","용도","요소","해당 웹 페이지","독자적","소프트웨어","속성","예","음악 사이트","앨범 트랙","음악","리스트 형식","리스트 형식","속성","음악 시간","음악 사이트","상관","외부","음악 시간","목적","해당 사이트","자체 스크립트"]},{"id":10,"category":"HTML","title":"script 태그","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"<script> : HTML 파싱이 중단되고 즉시 스크립트가 로드되며 로드된 스크립트가 실행되고 파싱이 재개된다.\n<script async> : HTML 파싱과 병렬적으로 로드가 되는데, 스크립트를 실행할 때는 파싱이 중단된다. 구글 애널리틱스와 같이 다른 스크립트가 의존하지 않는 독자적인 스크립트를 로드할 때 적합하다.\n<script defer> : HTML 파싱과 병렬적으로 로드가 되는데, 파싱이 끝나고 스크립트를 로드한다. 보통 <body> 태그 직전에 <script> 를 삽입하는 것과 동작은 같지만 브라우저 호환성에서 다를 수 있으므로 그냥 <body> 태그 직전에 삽입하는 것이 좋다.","keywordArray":["HTML 파싱","즉시 스크립트","스크립트","파싱","병렬적","로드","스크립트","파싱","구글 애널리틱스","스크립트","스크립트","병렬적","로드","파싱","스크립트","태그 직전","script","브라우저 호환성","태그 직전"]},{"id":11,"category":"HTML","title":"시맨틱 마크업","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"시맨틱(Semantic)이란 \"의미론적인\" 의 뜻을 가지며 마크업(Markup)이란 HTML 태그로 문서를 작성하는 것을 말한다. 따라서, 시맨틱 마크업이란 의미를 잘 전달하도록 문서를 작성하는 것을 말한다.\n검색엔진이 시맨틱 태그를 중요한 키워드로 간주하기 때문에 검색엔진 최적화(SEO)에 유리하다.\n웹 접근성 측면에서, 시각장애가 있는 사용자로 하여금 그 의미를 훨씬 잘 파악할 수 있다.\n단순한 div , span 으로 둘러싸인 요소들보다 코드를 볼 때 가독성이 더 좋다.\n실무에서 시맨틱 마크업이 완벽하게 쓰이는 것은 이상적이긴 하지만, 이러한 특징들을 고려하고 웹사이트를 구성하는 것이 많은 측면에서 바람직하다.","keywordArray":["의미론","뜻","HTML 태그","문서","의미","문서","검색 엔진","시맨틱 태그","키 워드","SEO","웹 접근성측면","시각 장애","사용자","의미","span","요소들","코드","때 가독성","실무","시맨틱 마크업","특징들","웹 사이트","측면"]},{"id":12,"category":"자바스크립트","title":"실행 컨텍스트 (Execution Context)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"실행 컨텍스트란 코드의 실행환경에 대한 여러가지 정보를 담고 있는 개념 으로, 간단히 말하자면 자바스크립트 엔진에 의해 만들어지고 사용되는 코드 정보를 담은 객체의 집합이라고 할 수 있다.\n자바스크립트의 코드는 3가지 종류로 이루어지는데, 글로벌 스코프에서 실행하는 글로벌 코드, 함수 스코프에서 실행하는 함수 코드 그리고 여기서 다루진 않지만 eval() 로 실행되는 코드가 있다. 이 각각의 코드는 자신만의 실행 컨텍스트를 생성한다.\n\n엔진이 스크립트 파일을 실행하기 전에 글로벌 실행 컨텍스트(Global Execution Context, GEC) 가 생성되고, 함수를 호출할 때마다 함수 실행 컨텍스트(Function Execution Context, FEC) 가 생성된다. 주의할 점은, 글로벌의 경우 실행 이전에 생성되지만 함수의 경우 호출할 때 생성된다는 점이다. ","keywordArray":["코드","실행 환경","정보","개념","자바스크립트 엔진","코드 정보","객체","자바스크립트","종류","글로벌 스코프","함수 스코프","함수 코드","eval","코드","각각","자신","실행 컨텍스트","엔진","스크립트 파일","전","함수","글로벌","경우 실행 이전","함수"]},{"id":13,"category":"자바스크립트","title":"AJAX","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"AJAX란 Asynchronous Javascript And XML의 약자로, 비동기적으로 JS를 사용해서 데이터를 받아와 동적으로 DOM을 갱신 및 조작하는 웹 개발 기법을 의미한다. 여기서 XML이 있는 이유는 예전엔 데이터 포맷으로 XML을 많이 사용했기 때문이다. \n사용자가 AJAX가 적용된 UI와 상호작용하면, 서버에 AJAX 요청을 보내게 된다. 서버는 DB에서 데이터를 가져와서 JS 파일에 정의되어 있는 대로 HTML/CSS와 데이터를 융합하여 만든 DOM 객체를 UI에 업데이트 시킨다. 비동기로 이루어지며, 기존의 페이지를 전부 로딩하는 방식이 아닌 일부만 업데이트 하는 방식이다.","keywordArray":["Asynchronous Javascript And XML","약자","동기적","JS","데이터","동적","DOM","웹 개발 기법","XML","예전","데이터 포맷","XML","사용","AJAX","서버","AJAX 요청","DB","데이터","JS 파일","데이터","DOM 객체","UI","동기","기존","페이지","방식"]},{"id":14,"category":"자바스크립트","title":"이벤트 버블링과 캡쳐링","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"이벤트 버블링 이란, 하위 엘리먼트에 이벤트가 발생할 때 그 엘리먼트부터 시작해서 상위요소까지 이벤트가 전달되는 방식을 말한다.\n\n이벤트 캡쳐링 이란, 하위 엘리먼트에 이벤트 핸들러가 있을 때 상위 엘리먼트부터 이벤트가 발생하기 시작해서 하위 엘리먼트까지 이벤트가 전달되는 방식을 말한다.","keywordArray":["하위 엘리먼트","이벤트","이벤트","방식","하위 엘리먼트","이벤트 핸들러","이벤트","이벤트","방식"]},{"id":15,"category":"자바스크립트","title":"이벤트 위임","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"이벤트 위임 이란 하위 엘리먼트들이 여러개 있을 때, 하위 엘리먼트들에 각각 이벤트 핸들러를 달지 않고 상위 엘리먼트에 이벤트 핸들러를 달아 하위 엘리먼트들을 제어하는 방식이다. 이 패턴으로 얻는 이점들은 다음과 같다.\n\n동적으로 엘리먼트를 추가할 때마다 핸들러를 고려할 필요가 없다.\n상위 엘리먼트에 하나의 이벤트 핸들러만 추가하면 되기 때문에 코드가 훨씬 깔끔해진다.\n메모리에 있게되는 이벤트 핸들러가 적어지기 때문에 퍼포먼스 측면에서 이점이 있다.","keywordArray":["이벤트 위임 이란 하위 엘리먼트들","하위 엘리먼트들","이벤트 핸들러","상위 엘리먼트","이벤트 핸들러","하위 엘리먼트들","패턴","다음","동","엘리먼트","핸들러","필요","상위 엘리먼트","하나","코드","메모리","이벤트 핸들러","퍼포먼스 측면","이점"]},{"id":16,"category":"자바스크립트","title":"스코프","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"스코프란 자바스크립트 엔진이 참조의 대상이 되는 식별자(Identifier)를 검색할 때 사용하는 규칙의 집합 이다. 즉, 어떤 변수를 사용하거나 함수를 호출하려고 할 때 해당하는 식별자로 사용하는데, 그 식별자를 검색하는 메커니즘이라고 이해하면 된다.\n\n프로그래머가 코드를 짤 때, 변수 및 함수/블록 스코프를 어디에 작성하였는가에 따라 정해지는 스코프 를 렉시컬 스코프라고 한다. \"렉시컬(Lexical)\" 이라는 명칭이 붙은 이유는 자바스크립트 컴파일러가 소스코드를 토큰(Token)으로 쪼개서 의미를 부여하는 렉싱(Lexing) 단계에 해당 스코프가 확정되기 때문이다. 다시 쉽게 말하면, 변수 혹은 함수/블록이 어디에 써있는가를 보고 그 스코프를 판단하면 된다.\n\n","keywordArray":["스코프란 자바스크립트 엔진","참조","대상","Identifier","규칙","변수","함수","식별자","식별자","프로그래머","코드","블록 스코프","블록 스코프","작성하","스코프","명칭","자바스크립트 컴파일러","소스 코드","Token","의미","단계","해당 스코프","블록","블록","블록","스코프"]},{"id":17,"category":"자바스크립트","title":"모듈(module)이란?","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"모듈이란 여러 기능들에 관한 코드가 모여있는 하나의 파일 로 다음과 같은 것들을 위해 사용한다.\n\n유지보수성 : 기능들이 모듈화가 잘 되어있다면, 의존성을 그만큼 줄일 수 있기 때문에 어떤 기능을 개선한다거나 수정할 때 훨씬 편하게 할 수 있다.\n네임스페이스화 : 자바스크립트에서 전역변수는 전역공간을 가지기 때문에 코드의 양이 많아질수록 겹치는 네임스페이스가 많아질 수 있다. 그러나 모듈로 분리하면 모듈만의 네임스페이스를 갖기 때문에 그 문제가 해결된다.\n재사용성 : 똑같은 코드를 반복하지 않고 모듈로 분리시켜서 필요할 때마다 사용할 수 있다.","keywordArray":["기능들","코드","하나","파일","다음","기능들","모듈화","의존성","기능","자바스크립트","전역 공간","코드","양","네임스페이스","모듈","모듈","네임스페이스","문제","코드","모듈"]},{"id":18,"category":"자바스크립트","title":"이벤트 루프 (Event loop)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"자바스크립트는 단일 스레드(Single-threaded) 기반 언어 로, 자바스크립트 엔진이 단일 콜 스택을 갖는다. 이 말은 요청이 동기적으로 처리된다는 것을 의미한다. 그렇다면 비동기 요청은 어떻게 처리될 수 있을까? 그것은 바로 자바스크립트를 실행하는 환경인 브라우저나 Node.js가 담당한다. 여기서 자바스크립트 엔진과 그 실행 환경을 상호 연동시켜주는 장치가 바로 이벤트 루프이다. 따라서, 이벤트 루프는 자바스크립트 엔진에 있지 않고 그 환경에 속한다.\n자바스크립트의 실행 환경은 2가지 큐를 가지고 있으며 각각 스크립트 실행, 이벤트 핸들러, 콜백함수 등의 태스크(Task) 담기는 공간이다. 태스크가 콜백함수라면 그 종류에 따라 다른 큐에 담기며 대표적인 예로는 다음과 같은 것들이 있다.\n\n태스크 큐\nsetTimeout() , setInterval() , UI 렌더링, requestAnimationFrame()\n마이크로태스크 큐\nPromise, MutationObserver\n이벤트 루프는 2개의 큐를 감시하고 있다가 콜 스택이 비게 되면, 콜백함수를 꺼내와서 실행한다. 이 때 마이크로태스크 큐의 콜백함수가 우선순위를 가지기 때문에 마이크로태스크 큐의 콜백함수를 전부 실행하고 나서 태스크 큐의 콜백함수들을 실행한다. (단, UI 렌더링이 태스크 큐에 속하기 때문에 마이크로태스크 큐의 태스크가 많으면 렌더링이 지연될 수 있다.)","keywordArray":["기반 언어","자바스크립트 엔진","단일 콜 스택","요청","동기적","자바스크립트","js","실행 환경","장치","자바스크립트 엔진","환경","자바스크립트","큐","태스크","종류","큐","예","다음","큐","콜 스택","콜백 함수","때 마이크로태스크 큐","콜백 함수","우선 순위","마이크로 태스크 큐","콜백 함수","태스크 큐","콜백 함수들","UI 렌더링","태스크 큐","마이크로 태스크 큐","태스크","렌더링"]},{"id":19,"category":"네트워크","title":"TCP (Transmission Control Protocol)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"TCP란 데이터가 반드시 전달되는 것을 보장하는 프로토콜로 다음 특징들을 갖는다.\n\n연결지향(Connection-oriented) 으로 2개의 호스트가 통신을 하기 전 연결이 이루어져야 한다.\n높은 신뢰성(Reliability) 과 순서대로 전송하는 것(In-order delivery) 을 보장한다.\n흐름 제어(Flow control) 를 통해 송신자의 데이터 양을 조절한다.\n혼잡 제어(Congestion control) 를 통해 네트워크 상황을 감지하고 송신자의 데이터 양을 조절한다.\n에러 감지(Error detection) 를 통해 잘못 전송되었을 경우 재전송한다.\n전 이중(Full duplex) 방식 으로 두 호스트 모두 송신자와 수신자가 될 수 있다.\n바이트 스트림(Byte stream) 을 사용하여 데이터를 연속적인 바이트로 보고, 세그먼트(Segment) 라는 단위의 패킷으로 쪼개서 보낸다.\nHTTP, FTP, SMTP, TELNET 등에서 사용된다.","keywordArray":["TCP란 데이터","프로토콜","다음 특징들","oriented","호스트","통신","전 연결","order delivery","Flow control","송신자","데이터 양","Congestion control","네트워크 상황","송신자","데이터 양","Error detection","방식","수신자","Byte stream","데이터","바이트","단위","패킷"]},{"id":20,"category":"네트워크","title":"UDP (User Datagram Protocol)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"UDP는 TCP와 달리 데이터의 신뢰성을 보장하지 않는 프로토콜이며 다음 특징들을 갖는다.\n\n비연결형(Connection-less) 으로 연결을 설정하고 해제하는 과정이 없다.\n신뢰성이 없고 전송되는 데이터의 순서를 보장하지 않는다.\n흐름제어, 혼잡제어가 없다.\n에러감지는 헤더의 체크섬(Checksum)을 이용한 정도밖에 없다.\n패킷의 단위가 데이터그램(Datagram) 으로 경계가 분명 하여 수신자는 송신자가 보낸 그대로의 크기로 받게 된다.\n서버와 클라이언트는 유니캐스트(1:1), 브로드캐스트(1:N), 멀티캐스트(1:M)가 가능하다. (N은 전체, M은 일부)\nTCP에 비해서 하는 작업들이 굉장히 적기 때문에 속도가 빠르다.\nDNS, DHCP, 비디오/오디오 스트리밍 등에 사용된다.","keywordArray":["TCP","데이터","신뢰성","다음 특징들","less","연결","과정","신뢰","데이터","순서","혼잡 제어","헤더","Checksum","패킷","단위","Datagram","경계","송신자","송신자","크기","M","TCP","작업들","속도"]},{"id":21,"category":"네트워크","title":"HTTP의 특징","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"HTTP의 특징 두가지는 아래와 같다.\n비-연결 지향 (Connectionless)\n클라이언트가 서버에게 리소스를 요청한 후 응답을 받으면 연결을 끊어버리는 특징이다. 연결을 유지하게 되면 서버에 많은 부담을 줄 수 있기 때문에 상당히 많은 클라이언트에게 요청을 받는 웹 서버의 경우 응답을 처리했으면 연결을 끊는다. 이로 인해 서버의 부담을 줄일 수 있지만, 리소스를 요청할 때마다 연결해야 하는 오버헤드 비용이 발생한다. 이를 해결하기 위해선, 요청 헤더의 Connection: keep-alive 속성으로 지속적 연결 상태(Persistent connection)를 유지할 수 있다. 즉, 요청을 할 때마다 연결하지 않고 기존의 연결을 재사용하는 방식이다. HTTP 1.1 부턴 지속적 연결 상태가 기본이며 이를 해제하기 위해선 명시적으로 요청 헤더를 수정해야 한다.\n\n무상태성 (Stateless)\n각각의 요청이 독립적으로 여겨지는 특징으로, 서버는 클라이언트의 상태를 유지하지 않는다. 즉, 각 클라이언트에 맞게 리소스를 응답하는 것은 불가능하다. 이를 해결하기 위해, 쿠키나 세션 또는 토큰 방식의 OAuth 및 JWT가 사용된다.","keywordArray":["HTTP","아래","클라이언트","서버","리소스","후 응답","연결","연결","서버","부담","클라이언트","요청","웹 서버","경우 응답","연결","서버","부담","리소스","오버 헤드 비용","요청 헤더","alive 속성","Persistent connection","요청","기존","연결","연결 상태","기본","명시적","요청 헤더","각각","요청","독립적","특징","클라이언트","상태","클라이언트","리소스","토큰 방식","JWT"]},{"id":22,"category":"네트워크","title":"HTTPS의 개념","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"HTTPS(HyperText Transfer Protocol over TLS/SSL)는 기존의 HTTP를 암호화한 프로토콜 로 보안이 강화된 버전이다. 약어에서의 \"S\"가 원래 SSL(Secure Socket Layer)의 약자였지만 SSL 버전 3.1부터 TLS(Transport Layer Security)로 명칭이 바뀌고 TLS와 혼용하고 있다. TCP의 연결이 이루어진 후 TLS를 통해 암호화 설정이 되고 통신을 하는 방식이다.\n\n공개키(Public Key)와 비밀키(Private Key) : 공개키는 모두가 볼 수 있는 키이며 비밀키는 소유자만이 가지고 있는 키로 암/복호화에 사용된다.\n대칭키 암호화 : 서버와 클라이언트가 암호화/복호화에 동일한 비밀키를 사용하는 방식, 키를 공유하는데 어려움이 있으나 속도가 빠르다.\n비대칭키 암호화 : 서버와 클라이언트가 암호화/복호화에 각각 다른 비밀키를 사용하는 방식, 공개키를 통해서 암호화를 하고 비밀키를 통해서 복호화를 한다. 공개키는 공개해도 상관없으니 키 관리에 어려움이 없으나, 속도가 느리다.\n인증기관(Certificate Authority, CA) : 클라이언트가 접속을 요청한 서버가 의도한 서버가 맞는지 인증해주는 역할을 하는 보증된 기업들이다. 클라이언트는 서버에 요청을 해서 CA가 발급한 인증서를 받은 뒤 CA의 공개키로 복호화하여 신뢰할 만한 인증서인지 검증한다. CA의 공개키로 복호화되는 암호화는 오직 CA의 비밀키로 암호화한 경우밖에 없기 때문에 복호화되면 신뢰할 만한 것이다.","keywordArray":["기존","HTTP","프로토콜","보안","약어","약어","S","Secure Socket Layer","Transport Layer Security","명칭","TCP","연결","후 TLS","암호화설정","통신","모두","소유자","키","복호화","클라이언트","복호화","비밀 키","키","어려움","속도","클라이언트","복호화","비밀 키","공개 키","암호화","비밀 키","복호화","키 관리","어려움","속도","클라이언트","접속","서버","서버","역할","서버","요청","CA","인증서","뒤 CA","공개","CA","공개","CA","비밀하"]},{"id":23,"category":"네트워크","title":"REST Api","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"REST란 REpresentational State Transfer의 약자로 전반적인 웹 어플리케이션에서 상호작용하는데 사용되는 웹 아키텍쳐 모델이다. 즉, 자원을 주고받는 웹 상에서의 통신 체계에 있어서 범용적인 스타일을 규정한 아키텍쳐 라고 할 수 있다.\n\nREST의 특징들\n균등한 인터페이스 (Uniform Interface)\nREST가 HTTP의 표준만 따른다면 어떠한 기술이던지 접목하여 사용할 수 있기 때문에 플랫폼이나 언어의 제약에 구애받지 않는다. 요즘은 REST API를 정의할 때 JSON(JavaScript Object Notation) 방식을 가장 많이 사용하지만 XML(eXtensible Markup Language)도 적용할 수 있다.\n\n무상태성 (Stateless)\n서버는 클라이언트의 상황을 고려하지 않고 API 요청에 대해서만 처리하기 때문에 이를 \"상태가 없다\" 라고 표현한다. 이렇게 되면 클라이언트를 고려하지 않아도 되기 때문에 구현이 간결해진다.\n\n캐싱 가능 (Cacheable)\nREST는 HTTP 표준을 기반으로 만들어졌기 때문에 HTTP의 특징인 캐싱을 사용할 수 있다. REST API를 활용하여 GET 메소드를 Last-Modified 값과 함께 보낼 경우, 컨텐츠의 변화가 없을 때 캐시된 값을 사용하게 된다. 이렇게 되면 네트워크 응답시간 뿐만 아니라 API 서버에 요청을 발생시키지 않기 때문에 부담이 덜 하다는 장점 또한 가지게 된다.\n\n자체 표현성 (Self-Descriptiveness)\nREST API의 자원명시 규칙 및 메소드는 그 자체로 의미를 지니기 때문에 어떠한 요청에 있어서 그 요청 자체로 어떤 것을 표현하는지 알아보기 쉽다. 물론 API를 규정한 각 서비스들이 문서를 제공하지만 이 특성에 따라서 요청하는 방식만으로 어떠한 의미인지 알 수 있어야 좋은 REST API라고 할 수 있다.\n\n클라이언트-서버 구조 (Client-Server Architecture)\nREST 서버가 API를 제공하는 방식이기 때문에 클라이언트에서 처리하는 부분과 독립적으로 동작한다. 따라서, 서로간의 의존성이 줄어들고 클라이언트와 서버를 최대한 독립적으로 개발할 수 있도록 도와준다.\n\n계층형 구조 (Layered System)\n클라이언트는 계층형 구조가 불가능하지만 REST 서버의 경우, 보안/로드 밸런싱/암호화 등을 추가할 수 있고 Proxy 및 게이트웨이 등의 중간매체를 사용할 수 있다.","keywordArray":["REpresentational State Transfer","약자","웹 어플리케이션","자원","웹 상","웹 상","통신 체계","스타일","아키텍","REST","REST","HTTP","언어","제약","REST API","방식","클라이언트","상황","API 요청","상태","상태","클라이언트","구현","HTTP 표준","기반","HTTP","캐싱","REST API","GET 메소드","Modified 값","컨텐츠","변화","값","API 서버","요청","부담","REST API","자체","의미","요청","요청 자체","API","서비스들","문서","특성","방식","REST 서버","API","클라이언트","독립적","의존성","서버","독립적","계층형구조","REST 서버","중간 매체"]},{"id":24,"category":"네트워크","title":"Cookie","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"쿠키란 클라이언트의 웹 브라우저에 저장되는 작은 데이터 조각으로 서버가 클라이언트의 요청을 식별하는데 사용된다. 쿠키를 활용해서 사용자를 구분하는게 매우 유용하지만, 클라이언트가 수정할 수도 있고 해커가 탈취할 수도 있기 때문에 보안에 취약하다. 따라서, 아이디 및 비밀번호와 같은 민감한 정보들을 저장하는데 사용하지는 않고 아래와 같은 목적으로 사용한다.\n\n세션 ID 관리, 서버에 저장해야 할 민감한 정보에 대한 식별자 ID\n개인화, 사용자 선호 및 테마\n트래킹, 사용자 행동 기록 및 분석","keywordArray":["클라이언트","웹 브라우저","데이터 조각","서버","클라이언트","요청","쿠키","사용자","클라이언트","해커","보안","비밀 번호","정보들","아래","목적","서버","정보"]},{"id":25,"category":"네트워크","title":"Session","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"세션이란 브라우저가 서버에 연결되어 있는 동안 유지하는 데이터 집합이다. 사용자가 웹 사이트에 방문하여 서버에 요청을 보내게 되면, 사용자의 정보를 서버에 저장하고 그 정보를 식별할 수 있는 \"세션 ID\"를 Set-Cookie 헤더로 클라이언트에게 전송한다. 위에서 말했던 것처럼 클라이언트는 쿠키로 세션 ID를 관리하고 해당 서버에 요청할 때마다 Cookie 헤더에 세션 ID를 포함시켜 전송하기 때문에 서버는 클라이언트를 식별하여 그에 맞는 정보를 응답으로 줄 수 있게 된다. 따라서, 아래와 같은 목적으로 사용한다고 할 수 있다.\n\n민감한 정보 관리, 사용자의 비밀번호 및 개인정보","keywordArray":["브라우저","서버","사용","웹 사이트","서버","요청","사용자","정보","서버","정보","세션 ID","Cookie 헤더","클라이언트","위","쿠키","세션 ID","해당 서버","Cookie 헤더","세션 ID","클라이언트","식별하","정보","응답","아래","목적","사용자"]},{"id":26,"category":"네트워크","title":"Cookie vs Session","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"쿠키\n클라이언트 쪽에 저장한다. (웹 브라우저)\n브라우저가 꺼져도 삭제되지 않고 사용자가 삭제하거나 정해진 시간만큼 유지된다.\n문자열만 저장할 수 있다.\n클라이언트에서 보내기 때문에 속도가 빠르다.\n민감한 데이터를 스니핑 당할수도 있기 때문에 보안에 취약하다.\n세션\n서버쪽에 저장한다. (서버의 메모리 혹은 데이터베이스)\n브라우저가 꺼질 경우 삭제된다.\n문자열 뿐 아니라 객체도 저장할 수 있다.\n서버쪽에서 처리하기 때문에 속도가 비교적 느리다.\n서버에서 민감한 데이터를 갖고 있기 때문에 비교적 보안이 좋다.","keywordArray":["브라우저","사용자","클라이언트","속도","데이터","보안","서버","브라우저","속도","서버","데이터","보안"]},{"id":27,"category":"네트워크","title":"CDN (Contents Delivery Network)","source":"https://github.com/baeharam/Must-Know-About-Frontend/","originalText":"CDN은 컨텐츠 전달 네트워크의 약자로 말 그대로, 컨텐츠를 전달하는 네트워크를 구성하는 것이다. 보통 웹사이트를 로딩할 때는 웹 서버에 HTTP 요청을 하여 리소스를 가져오지만 웹 서버가 아니라 현재 사용자가 접속한 위치에서 가장 가까운 서버에 리소스를 캐싱해놓고 보다 빠르게 가져오는 기법이다. 물론, CDN 네트워크를 구축하기 위해선 해당되는 지역의 ISP(인터넷 제공업체, Internet Service Provider), 네트워크 사업자, 이동통신 사업자에게 서버의 호스팅 비용을 지불해야 한다. 이렇게 네트워크를 구축하게 되면 정적 리소스를 더욱 빠른 속도로 서비스 할 수 있게 되는 것이다.","keywordArray":["컨텐츠 전달 네트워크","약자","컨텐츠","네트워크","웹 사이트","웹 서버","HTTP 요청","리소스","웹 서버","사용자","위치","서버","리소스","CDN 네트워크","지역","이동 통신 사업자","서버","호스팅 비용","네트워크","정적 리소스","속도"]}]